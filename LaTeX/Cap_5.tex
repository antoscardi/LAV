\documentclass[main]{subfiles}
\begin{document}
\section{Control}
The purpose of this chapter is to model the dynamical system 
of each UAV and describe the control strategies used to achieve the 
desired position and velocity, while ensuring stability and robustness.
The focus of our work is to localize the position of the 
avalanche victims, therefore the control task of the UAVs' flight 
is limited and interested mainly in controlling the altitude 
(maintaining a fixed height) and the horizontal positions
$x$ and $y$.

\noindent\\
Each $j$-th UAV is modeled as a quadrotor vehicle, the most common 
multirotor aerial platform, characterized by four rotors attached 
to a rigid cross-shaped airframe. Each rotor generates 
both a force and a torque. The dynamics of each quadrotor are 
described using Euler-Newton laws of motion, with the motion 
expressed in terms of both the inertial frame \( F_g \) and the 
body frame \( F_b \).
As already mentioned, we have assumed the body frame $F_b$
to coincide with the receiver frame $F_r$, relative to the
the ARTVA equipment installed on the UAV; therefore 
from now on we will denote the body frame with $F_r$.

\noindent\\
The control of this underactuated system introduces more challenges 
compared to wheeled robots \cite{model_quadrotor}. This section begins 
by presenting the fundamental notations and conventions, 
followed by the complete dynamical model of the UAV. A simplified model is 
then introduced, which assumes small angles to implement a 
Proportional-Integral-Derivative (PID) control strategy. 
Finally, a hierarchical control strategy, used to regulate the 
quadrotor's position and velocity, is discussed in detail, 
including both an outer position control in cascade with an inner 
attitude control mechanisms.

\subsection{Notations}
We introduce the notations and conventions used in this work 
to model the quadrotor dynamics and control. 
In particular, in Table~\ref{tab:notations} we introduce and 
summarize all the quantities and variables needed:
\begin{table}[H]
    \centering
    \caption{\textbf{UAV Quadrotor System Quantities}}
    \begin{tabular}{ccc}
        \hline\hline
        \textbf{Symbol} & \textbf{Description} & \textbf{Unit} \\
        \hline
        \(g\) & gravitational acceleration constant, \( g \in \mathbb{R}_{\geq 0} \) & m/s\(^2\) \\
        \(m\) & mass of the quadrotor, \( m \in \mathbb{R}_{\geq 0} \) & kg \\
        \(x_r\) & position of the quadrotor along \(x\) (east) in \(F_g\) & m \\
        \(y_r\) & position of the quadrotor along \(y\) (north) in \(F_g\) & m \\
        \(z_r\) & position of the quadrotor along \(z\) (up) in \(F_g\) & m \\
        \(v_x\) & linear velocity along \(x\) in \(F_g\) & m/s \\
        \(v_y\) & linear velocity along \(y\) in \(F_g\) & m/s \\
        \(v_z\) & linear velocity along \(z\) in \(F_g\) & m/s \\
        \(p\) & roll rate in \(F_b\) & rad/s \\
        \(q\) & pitch rate in \(F_b\) & rad/s \\
        \(r\) & yaw rate in \(F_b\) & rad/s \\
        \(\phi\) & roll angle (rotation about \(x\)-axis) & rad \\
        \(\theta\) & pitch angle (rotation about \(y\)-axis) & rad \\
        \(\psi\) & yaw angle (rotation about \(z\)-axis) & rad \\
        \(T\) & total thrust generated by the propellers, \( T \in \mathbb{R}_{\geq 0} \) & N \\
        \hline\hline
    \end{tabular}
    \label{tab:notations}
\end{table}

\noindent\\
The laws of motion are described in both the global inertial frame \( F_g \) 
(particularly for translational dynamics) and the body frame 
\( F_r \) (in which the rotational dynamics are expressed more 
easily). The body right-hand frame \( F_r \) is fixed to the quadrotor 
(rotates with it), with its 
origin located at the center of mass.
Its axes are defined as in \cite{model_quadrotor}:
\noindent
\begin{itemize}
    \item The \( x \)-axis points forward along the quadrotor's direction 
 of motion.
    \item The \( y \)-axis points to the left wing.
    \item The \( z \)-axis points upwards, consistent with 
 the thrust direction.
\end{itemize}

\noindent\\
For the inertial frame, we adopt a convention that does not use 
the standard NED\footnote{NED stands for North-East-Down.} inertial 
reference frame, to ensure consistency throughout our work. 
Instead, the inertial frame \( F_g \) follows the ENU 
\footnote{ENU stands for East-North-Up.} 
convention (Figure \ref{fig:ENU}), where the 
\( z \)-axis points upward, away from the center of the Earth. The 
inertial frame \( F_g \) is fixed to the ground, with its origin at a 
reference point (the takeoff location), and its axes are defined as:
\begin{itemize}
    \item The \( x \)-axis points east.
    \item The \( y \)-axis points north.
    \item The \( z \)-axis points opposite the gravity vector.
\end{itemize}
The ENU local tangent plane is similar to NED, except for swapping 
"down" for "up" and \( x \) for \( y \), which is more intuitive for certain 
geographical and aerial applications.

\begin{figure}
    \centering
    \includegraphics[width=0.5\textwidth]{images/ECEF_ENU_Longitude_Latitude_relationships.png}
    \caption[ENU and ECEF Reference Frames]{A diagram illustrating the ECEF (Earth-Centered, Earth-Fixed) 
 and ENU reference frames. 
 Adapted from a figure in \cite{ENU}.}
    \label{fig:ENU}
\end{figure}
%(IN REALTÀ È PRESA DA WIKI, VA BENE SI PUO FARE?)

\noindent\\
The orientation of the rigid body with respect to the inertial
frame is described by the rotation matrix 
\( \mathbf{R}^g_r(t) \in SO(3) \), which transforms vectors from the 
body frame \( F_r \) to the inertial frame \( F_g \).
The \( \mathbf{R}^g_r(t) \) rotation matrix is obtained by successive rotations around the 
inertial frame axes, these rotations define the roll, pitch, and yaw angles \((\phi, \theta, \psi)\).
We specify the order of rotations as $x -y -z $:
\begin{itemize}
    \item yaw (\( \psi \)): rotation about the \(z\)-axis of the inertial frame \( F_g \).
    \item pitch (\( \theta \)): rotation about the \(y\)-axis of the inertial frame \( F_g \).
    \item roll (\( \phi \)): rotation about the \(x\)-axis of the inertial frame \( F_g \).
\end{itemize}

\noindent\\
Since the successive rotations are relative to the fixed reference frame,
the full rotation matrix \( \mathbf{R}^g_r(t) \) is obtained as a product of the three individual rotation matrices:
\begin{align}
\mathbf{R}^g_r & = 
\mathbf{R}_z(\psi) \mathbf{R}_y(\theta) \mathbf{R}_x(\phi) \nonumber\\
& =
\begin{bmatrix}
\cos\psi & -\sin\psi & 0 \\
\sin\psi & \cos\psi & 0 \\
0 & 0 & 1
\end{bmatrix}
\begin{bmatrix}
\cos\theta & 0 & \sin\theta \\
0 & 1 & 0 \\
-\sin\theta & 0 & \cos\theta
\end{bmatrix}
\begin{bmatrix}
1 & 0 & 0 \\
0 & \cos\phi & -\sin\phi \\
0 & \sin\phi & \cos\phi
\end{bmatrix} \nonumber\\ 
& =
\resizebox{0.84\textwidth}{!}{$
\begin{bmatrix}
\cos\psi \cos\theta & \cos\psi \sin\theta \sin\phi - \sin\psi \cos\phi & \cos\psi \sin\theta \cos\phi + \sin\psi \sin\phi \\
\sin\psi \cos\theta & \sin\psi \sin\theta \sin\phi + \cos\psi \cos\phi & \sin\psi \sin\theta \cos\phi - \cos\psi \sin\phi \\
-\sin\theta & \cos\theta \sin\phi & \cos\theta \cos\phi
\end{bmatrix}
$}
\label{eq:attitude}
\end{align}
    
    
\noindent\\
\textbf{Note}\noindent\\
Considering \( \mathbf{x} \in \mathbb{R}^3 \), we define a square matrix to 
be skew-symmetric \( \mathbf{S}(\mathbf{x}) \in \mathfrak{so}(3) \)
if and only if:
\begin{equation}
\mathbf{S}(\mathbf{x})\mkern-3mu^\top \mkern-4mu + \mathbf{S}(\mathbf{x}) = 0
\label{eq:skew_symmetric_condition}
\end{equation}

\noindent\\
Any rotation matrix \( \mathbf{R}(t) \in SO(3)\) satisfies the orthogonality condition:
\begin{equation}
\mathbf{R}(t) \, \mathbf{R}\mkern-3mu^\top\mkern-4mu(t) = \mathbf{I}
\label{eq:orthogonality_condition}
\end{equation}

\noindent\\
Computing the time derivative on both sides of \ref{eq:orthogonality_condition} gives:
\begin{equation}
\dot{\mathbf{R}}(t) \, \mathbf{R}\mkern-3mu^\top\mkern-4mu(t) + \mathbf{R}(t) \, \dot{\mathbf{R}}\mkern-3mu^\top\mkern-4mu(t) = 0
\label{eq:time_derivative_orthogonality}
\end{equation}

\noindent\\
This is the skew-symmetry condition \eqref{eq:skew_symmetric_condition} 
for a matrix defined as:
\begin{equation}
\mathbf{S}(t) \stackrel{\Delta}{=} \dot{\mathbf{R}}(t) \, \mathbf{R}(t)\mkern-3mu^\top
\label{eq:def_skew_symmetric}
\end{equation}

\noindent\\
By post multiplying $\mathbf{R}(t)$ on both sides of \ref{eq:def_skew_symmetric} we
obtain an expression for the variation in time of any rotation matrix:
\begin{equation}
\dot{\mathbf{R}}(t) = \mathbf{S}(t) \, \mathbf{R}(t)
\label{eq:skew_symmetric_rotation}
\end{equation}

\noindent\\
Since $\mathbf{R}(t)$ is the product of basic rotations with respect to the fixed frame and  
denoting with $ \boldsymbol{\omega}(t) = (\omega_x, \omega_y,  \omega_z)^\top \in \mathbb{R}^3$ the angular velocity of the body frame with respect to the fixed frame, 
we can repeat the same process to find an expression of $\mathbf{S}$ which depends on the time
derivative of the orientation angles, \cite{book-robotics}:
\begin{equation}
\mathbf{S}(\boldsymbol{\omega}) = 
\begin{bmatrix}
    0 & -\omega_z & \omega_y \\
    \omega_z & 0 & -\omega_x \\
 -\omega_y & \omega_x & 0
\end{bmatrix}
\label{eq:skew_symmetric_matrix}
\end{equation}

\noindent\\
Furthermore, the angular velocity of the rotating body frame with respect to the fixed frame is related to the angular velocity
expressed in the receiver frame as:
\begin{equation}
 \boldsymbol{\omega} = \mathbf{R}^g_r \, {}^r\mkern-3mu\boldsymbol{\omega}
    \label{eq:angular_velocity_inertial}
\end{equation}

\noindent\\
Then, we substitute Eq.\ref{eq:angular_velocity_inertial} in Eq.\ref{eq:def_skew_symmetric} to obtain the 
the skew-symmetric matrix of ${}^r \boldsymbol{\omega}$, in the body frame:
\begin{equation}
 \mathbf{S}(\boldsymbol{\omega}) =  \mathbf{S}(\mathbf{R}^g_r \, {}^r\mkern-3mu\boldsymbol{\omega}) 
    \label{eq:S_body}
\end{equation}

\noindent\\
Using the properties of skew-symmetric matrices:
\begin{equation}
 \mathbf{S}(\mathbf{R}^g_r \, {}^r\mkern-3mu\boldsymbol{\omega}) = \mathbf{R}^g_r \, \mathbf{S}({}^r\mkern-3mu\boldsymbol{\omega}) \, {\mathbf{R}^g_r}^\top 
    \label{eq:skew_symm_property}
\end{equation}

\noindent\\
Substituting this result \eqref{eq:skew_symm_property} in Eq.\ref{eq:skew_symmetric_rotation}:
\begin{equation}
 \dot{\mathbf{R}^g_r} = \mathbf{R}^g_r \, \mathbf{S}({}^r\mkern-3mu\boldsymbol{\omega}) \, {\mathbf{R}^g_r}\mkern-3mu^\top  \, \mathbf{R}^g_r = \mathbf{R}^g_r \, \mathbf{S}({}^r\mkern-3mu\boldsymbol{\omega})
    \label{eq:skew_symmetric_body}
\end{equation}
We obtain the same expression of the inertial frame in the body frame.

\subsection{Complete Quadrotor Dynamics}
\subsubsection{Translational Dynamics}
Since the position of the UAV's center of gravity is represented by \( \mathbf{p}_r \in \mathbb{R}^3 \), 
expressed in the inertial frame \( F_g \), we denote its time derivative as \( \dot{\mathbf{p}}_r \) and 
the linear acceleration as \( \ddot{\mathbf{p}}_r \).
%%%%%%%%%%%%%% QUI C E COME CI SI ARRIVA
% Applying Newton's second law in the body frame, the translational dynamics are expressed as:
% \[
% m \frac{\mathrm{d}}{\mathrm{d}t}\mathbf{v}^b = \mathbf{f}^b,
% \]
% where:
% \begin{itemize}
%     \item \(\mathbf{v}^b = [v_x^b, v_y^b, v_z^b]^\top\): Linear velocity in the body frame.
%     \item \(\mathbf{f}^b\): Total force acting on the quadrotor, including thrust, drag, and gravity.
% \end{itemize}
% In the inertial frame, the translational dynamics of the quadrotor are given by:
% \[
% m \ddot{\mathbf{p}} = \mathbf{R}^\top \mathbf{f}^b - m g \mathbf{e}_z,
% \]
% where:
% \begin{itemize}
%     \item \(\ddot{\mathbf{p}}\): Acceleration of the quadrotor in the inertial frame.
%     \item \(\mathbf{e}_z = [0, 0, 1]^\top\): Unit vector in the \(z\)-direction of the inertial frame.
%     \item \(\mathbf{f}^b = [0, 0, f_{\text{thrust}}]^\top\): Force vector due to thrust in the body frame.
% \end{itemize}
% By transforming gravity into the body frame, we write:
% \[
% \mathbf{f}^b = \mathbf{R} \mathbf{f}^i,
% \]
% where \(\mathbf{f}^i\) includes gravitational and aerodynamic forces expressed in the inertial frame.

\noindent\\
Then, by applying Newton-Euler's first law, we obtain the 
translational dynamics of the quadrotor in the fixed inertial frame $F_g$ as in \cite{simplified_model}:
\begin{equation}
m \ddot{\mathbf{p}}_r = \sum \mathbf{F}_{\text{ext}} 
= T \, \mathbf{R}_r^g \, \mathbf{e}_z - m g \, \mathbf{e}_z - \mathbf{d}_f
\label{eq:translational_dyn}
\end{equation}
where \( \mathbf{F}_{\text{ext}} \) denotes all the external forces acting on the vehicle, which
includes the thrust force \( T \in \mathbb{R}_{\geq 0} \) generated by the propellers and therefore  
represents the control force, the input of the system which can be controlled.
It is aligned with the body \( z \)-axis by construction, as it is the sum of the single
forces generated by the aligned rotors. 
It also includes the gravitational force \( m g \), which instead is always directed towards the center of 
the Earth and therefore negative in our ENU fixed reference system. 
Finally, \( \mathbf{d}_f \) represents the disturbance forces, accounting for exogenous effects such as 
aerodynamic drag and wind disturbances \cite{control_quadrotor_main}.


\subsubsection{Rotational Dynamics} 
Newton-Euler's second law describes the variation in time of the angular momentum of a rigid body $\mathbf{L}$ 
in terms of the inertial reference frame, \cite{quadrotor_modeling_control_book}, \cite{book-robotics}:
\begin{equation}
 \frac{\mathrm{d} \mathbf{L}}{\mathrm{d}t} = \sum \boldsymbol{\tau}_{\text{ext}}
    \label{eq:NE-2}
\end{equation}
where \( \mathbf{L} \in \mathbb{R}^3 \) is the angular momentum of the rigid body,
expressed in the fixed inertial frame \( F_g \), and \( \boldsymbol{\tau}_{\text{ext}} \in \mathbb{R}^3 \) 
represents the total applied torque about the center of mass, which includes contributions 
from the control inputs, external disturbances, and aerodynamic effects.

\noindent\\
The angular momentum \( \mathbf{L} \) is related to the angular velocity as:
\begin{equation}
 \mathbf{L} = \mathbf{J} \, \boldsymbol{\omega}
    \label{eq:angular_momentum}
\end{equation}
where \( \mathbf{J} \in \mathbb{R}^{3 \times 3} \) is the inertia matrix of the rigid body, 
which is symmetric and positive definite (\( \mathbf{J} = \mathbf{J}^\top > 0 \)).

\noindent\\
However, it is more convenient to express the rotational dynamics 
in the body frame \( F_r \) of the rigid body, since the inertia matrix remains constant in this case. 
The opposite is not true, in fact, the inertia matrix in the inertial frame is given by:
\begin{equation}
 \mathbf{J} =  \mathbf{R}^g_r \, {}^r\mkern-3mu\mathbf{J} \, {\mathbf{R}^g_r}\mkern-2mu^\top 
    \label{eq:inertia_rot}
\end{equation}

\noindent\\
Therefore, we substitute this property of the inertia matrix \eqref{eq:inertia_rot} and 
Eq.\ref{eq:angular_velocity_inertial} in Eq.\ref{eq:NE-2}, 
and use the result obtained earlier in \ref{eq:skew_symmetric_body}:
\begin{align}
 \frac{\mathrm{d} (\mathbf{J} \boldsymbol{\omega})}{\mathrm{d}t} &= 
 \dot{\mathbf{R}}^g_r \, {}^r\mkern-3mu\mathbf{J} \, {\mathbf{R}^g_r}\mkern-2mu^\top {}^r\mkern-2mu\boldsymbol{\omega} +
 \mathbf{R}^g_r \, {}^r\mkern-3mu\mathbf{J} \, \dot{\mathbf{R}^g_r}\mkern-2mu^\top {}^r\mkern-2mu\boldsymbol{\omega} \notag 
 + \mathbf{R}^g_r \, {}^r\mkern-3mu\mathbf{J} \, {\mathbf{R}^g_r}\mkern-2mu^\top {}^r\mkern-2mu\dot{\boldsymbol{\omega}} \notag \\
    &= {}^r\mkern-3mu\mathbf{J} \, {}^r\dot{\boldsymbol{\omega}} + 
 {}^r\mkern-2mu\boldsymbol{\omega} \times ({}^r\mkern-3mu\mathbf{J} \, {}^r\mkern-2mu\dot{\boldsymbol{\omega}})
    \label{eq:derivazione_rotational_law}
\end{align}

\noindent\\
In the end, by comparing the right side of Eq.~\eqref{eq:derivazione_rotational_law}
with the right side of Eq.\ref{eq:NE-2}, we obtain as in \cite{control_quadrotor_main}
the complete rotational motion of the rigid body:
\begin{equation}
 {}^r\mkern-3mu\mathbf{J} \, {}^r\dot{\boldsymbol{\omega}} +
 {}^r\mkern-2mu\boldsymbol{\omega} \times ({}^r\mkern-3mu\mathbf{J} \, {}^r\mkern-2mu\dot{\boldsymbol{\omega}})
 = \sum \boldsymbol{\tau}_{\text{ext}}
    \label{eq:rot_dyn_final}
\end{equation}

\noindent\\
The inertia matrix \( {}^r\mkern-3mu\mathbf{J} \) depends on the geometry and mass distribution of the rigid body. 
For the quadrotor, assuming a rigid body structure with a dense spherical core of mass \( m_1 \) and radius \( r \), 
along with four-point masses \( m_2 \) located at a distance \( l \) from the center, 
the inertia matrix takes the diagonal form:
\[
{}^r\mkern-3mu\mathbf{J} = 
\begin{bmatrix}
J_x & 0 & 0 \\
0 & J_y & 0 \\
0 & 0 & J_z
\end{bmatrix},
\]
Where:
\[
J_x = J_y = \frac{2}{5} m_1 r^2 + 2 l^2 m_2, \quad J_z = \frac{2}{5} m_1 r^2 + 4 l^2 m_2
\]

\noindent\\
Substituting Eq.~\eqref{eq:angular_momentum} into Eq.~\eqref{eq:rot_dyn_final}, we obtain the 
rotational dynamics law:
\begin{equation}
 {}^r\mkern-3mu\mathbf{J} \, {}^r\mkern-4mu\dot{\boldsymbol{\omega}} + {}^r\mkern-4mu\boldsymbol{\omega} \times 
 ({}^r\mkern-3mu\mathbf{J} \, {}^r\mkern-4mu\boldsymbol{\omega}) = \boldsymbol{\tau}_{\text{u}} + \mathbf{d}_{\tau}
    \label{eq:rotational_dynamics}
\end{equation}
where $\boldsymbol{\tau}_{\text{u}} \in \mathbb{R}^3$ is the controlled input
torque vector dependent on the single torque generated
by each rotor and with $\mathbf{d}_{\tau}$ we denote 
all the external disturbances.

\noindent\\
In addition, we need to relate the angular velocity \( {}^r\mkern-4mu\boldsymbol{\omega} \) in the body frame 
to the time derivatives of the roll, pitch, and yaw angles (\( \phi, \theta, \psi \)) 
in the inertial frame. We assume that the variation of the angles  $\dot{\phi}, \dot{\theta}, \dot{\psi}$
is small and therefore $\dot{\mathbf{R}}_x(\phi) = \dot{\mathbf{R}}_x(\theta) =  \dot{\mathbf{R}}_x(\psi) = \mathbf{I}$:
\begin{equation}
 {}^r\boldsymbol{\omega} = 
    \begin{pmatrix}
 p \\ q \\ r
    \end{pmatrix}
 =
    \begin{pmatrix}
        1 & 0 & -\sin\theta \\
        0 & \cos\phi & \sin\phi\cos\theta \\
        0 & -\sin\phi & \cos\phi\cos\theta
    \end{pmatrix}
    \begin{pmatrix}
 \dot{\phi} \\ \dot{\theta} \\ \dot{\psi}
    \end{pmatrix}
    \label{eq:angular_rates_to_rpy}
\end{equation}

\noindent\\
Finally, also the rotation matrix \( \mathbf{R}_r^g (t) \) 
evolves in time as the rigid body rotates in space, following the result obtained earlier
in Eq.\ref{eq:skew_symmetric_body}:
\begin{equation}
 \dot{\mathbf{R}}_r^g = \mathbf{R}_r^g \, \mathbf{S}({}^r\boldsymbol{\omega})
    \label{eq:rotation_matrix_dynamics_final}
\end{equation}
where \( \mathbf{S}({}^r\mkern-4mu\boldsymbol{\omega}) \) is a skew-symmetric matrix
in the form of \ref{eq:skew_symmetric_matrix}, but relative to the body frame components:
\begin{equation}
 \mathbf{S}({}^r\mkern-3mu\mathbf\boldsymbol{\omega}) = 
    \begin{bmatrix}
        0 & -r & q \\
        r & 0 & -p \\
        -q & p & 0
    \end{bmatrix}
\label{eq:skew_symmetric_matrix_body}
\end{equation}

\subsubsection{Final Complete Quadrotor Dynamics}
Combining the translational and rotational dynamics, the complete UAV dynamics is given by the system of Equations
\ref{eq:translational_dyn}, \ref{eq:rotation_matrix_dynamics_final} and \ref{eq:rotational_dynamics}:
\begin{equation}
\begin{cases}
 m \ddot{\mathbf{p}}_r = T \, \mathbf{R}_r^g \, \mathbf{e}_z - m g \, \mathbf{e}_z - \mathbf{d}_f \\[6pt]
 \dot{\mathbf{R}}_r^g = \mathbf{R}_r^g \, \mathbf{S}({}^r\mkern-4mu\boldsymbol{\omega}) \\[6pt]
 {}^r\mkern-4mu\mathbf{J} \, {}^r\mkern-4mu\dot{\boldsymbol{\omega}} = 
 - {}^r\mkern-4mu\boldsymbol{\omega} \times 
 ({}^r\mkern-4mu\mathbf{J} \, {}^r\mkern-4mu\boldsymbol{\omega}) + \boldsymbol{\tau}_{\text{u}} + \mathbf{d}_{\tau}   
\end{cases}
\label{eq:final_model}
\end{equation}

\noindent\\
More explicitly we can expand these equations and thanks to inverting Eq.\ref{eq:angular_rates_to_rpy}
and how we defined rotation matrix $\mathbf{R}_r^g$ in Eq.\ref{eq:attitude}, we obtain
a system with twelve states and four control inputs:\vspace{0.2cm}
%{\large
\begin{equation}
\begin{cases}
 \dot{x}_r = v_x \\[6pt]
 \dot{y}_r = v_y \\[6pt]
 \dot{z}_r = v_z \\[6pt]
 \dot{v_x} = -d_{f,x} + (\cos(\psi) \sin(\theta) \cos(\phi) + \sin(\psi) \sin(\phi)) \frac{T}{m} \\[8pt]
 \dot{v_y} = -d_{f,y} + (\sin(\psi) \sin(\theta) \cos(\phi) - \cos(\psi) \sin(\phi)) \frac{T}{m} \\[8pt]
 \dot{v_z} = -d_{f,z} - g + \cos(\theta) \cos(\phi) \frac{T}{m} \\[8pt]
 \dot{\phi} = p + \sin(\phi) \tan(\theta) q + \cos(\phi) \tan(\theta) r \\[8pt]
 \dot{\theta} = \cos(\phi) q - \sin(\phi) r \\[6pt]
 \dot{\psi} = \sin(\phi) \sec(\theta) q + \cos(\phi) \sec(\theta) r \\[8pt]
 \dot{p} =  \frac{I_y - I_z}{I_x} qr + \frac{\tau_\phi}{I_x} \\[10pt]
 \dot{q} =  \frac{I_z - I_x}{I_y} pr + \frac{\tau_\theta}{I_y} \\[10pt]
 \dot{r} =  \frac{I_x - I_y}{I_z} pq + \frac{\tau_\psi}{I_z}
\end{cases}
\label{eq:final_model_more}
\end{equation}%}
\noindent
where $\tau_{\phi}, \tau_{\theta}, \tau_{\psi}$ are the components of input
torque vector $\boldsymbol{\tau}_{\text{u}} = (\tau_{\phi}, \tau_{\theta}, \tau_{\psi})^\top $.

\noindent\\
In a compact state-space form:
\begin{equation}
 \dot{\boldsymbol{\xi}} = f(\boldsymbol{\xi}) + g(\boldsymbol{\xi}) \boldsymbol{u}
\end{equation}
where:
\[
\boldsymbol{\xi} = [x_r, y_r, z_r, v_x, v_y, v_z, \phi, \theta, \psi, p, q, r]^\top
\]
\[
\boldsymbol{u} = [T, \tau_\phi, \tau_\theta, \tau_\psi]^\top
\]
The non-linear dynamics of the state is described by \( f(\boldsymbol{\xi}) \), 
while \( g(\boldsymbol{\xi}) \) represents the control input relationships
with the system.


\subsection{Simplified Dynamics}
To facilitate control design, we consider a simplified model of the quadrotor dynamics,
as proposed in \cite{simplified_model}. 
This model assumes nominal conditions with no external 
disturbances and employs a small-angle approximation 
for the roll (\( \phi \)) and pitch (\( \theta \)) angles. 
Additionally, we assume a symmetric mass distribution 
and negligible aerodynamic and gyroscopic effects.


\noindent\\
Under these assumptions:
\begin{itemize}
    \item Small angular velocities and small angles allow \( (\dot{\phi}, \dot{\theta}, \dot{\psi}) \approx (p, q, r) \),
 simplifying the rotational dynamics.
    \item The Coriolis or gyroscopic term  \( {}^r\boldsymbol{\omega} \times (\mathbf{J} \, {}^r\boldsymbol{\omega}) \) 
 in the rotational dynamics is negligible for stabilization tasks, where angular velocities remain small.
\end{itemize}
The simplified dynamics are:
\begin{equation}
\begin{cases}
 m \ddot{\mathbf{p}}_r = T \, \mathbf{R}_r^g \, \mathbf{e}_z - m g \, \mathbf{e}_z \\[6pt]
 \mathbf{J} \, {}^r\mkern-4mu\dot{\boldsymbol{\omega}} = \boldsymbol{\tau}_{\text{u}}
\end{cases}
\label{eq:simplified_rotational_dynamics}
\end{equation}

\noindent\\
Explicitly expanded as:
\begin{subequations}
\begin{empheq}[left=\empheqlbrace]{align}
 \ddot{x}_r &= (\cos\psi \sin\theta \cos\phi + \sin\psi \sin\phi) \frac{T}{m} \label{eq:position_control_x}\\[6pt] 
 \ddot{y}_r &= (\sin\psi \sin\theta \cos\phi - \cos\psi \sin\phi) \frac{T}{m} \label{eq:position_control_y}\\[6pt] 
 \ddot{z}_r &= \cos\theta \cos\phi \frac{T}{m} - g  \label{eq:position_control_z}\\[6pt] 
 \dot{\phi} &= \frac{\tau_{\phi}}{I_x} \\[8pt]
 \dot{\theta} &= \frac{\tau_{\theta}}{I_y} \\[8pt]
 \dot{\psi} &= \frac{\tau_{\psi}}{I_z}
\end{empheq}
\label{eq:simplified_model}
\end{subequations}
\noindent\\
This simplified model reduces the complexity of the quadrotor dynamics,
making it adapt to be controlled by simple control strategies such as 
PID\footnote{PID stands for Proportional-Integral-Derivative} control.

\subsection{PID Control}
\label{sec:PID_control}
In this section, we implement a PID controller 
based on the simplified model from Section~\ref{eq:simplified_model},
but we also apply it to the full quadrotor dynamics described in Equations~\ref{eq:final_model_more},
to evaluate its effectiveness in a real-world scenario.

\noindent\\
The primal objective is to regulate the altitude $z$ and the 
horizontal positions \( x \) and \( y \) of the quadrotor along a 
specified trajectory $\mathbf{x}_d(t) \in \mathbb{R}^3$.
In order to do so we define position error $\mathbf{e}(t) \in \mathbb{R}^3$
between the actual position $p_r(t)$ f the $j$-th UAV and the desired trajectory as:
\[
 \mathbf{e}(t) = \mathbf{x}_d(t) - \mathbf{p}_r(t) = 
    \begin{bmatrix}
 e_x(t) \\
 e_y(t) \\
 e_z(t)
    \end{bmatrix} =
    \begin{bmatrix}
 x_d(t) - p_{r_x}(t) \\
 y_d(t) - p_{r_y}(t) \\
 z_d(t) - p_{r_z}(t)
    \end{bmatrix}
\]

\noindent\\
In Figure \ref{fig:control_traj_tracking}, we define the block
diagram which shows the hierarchical PID control of the full 
quadrotor dynamics.

\subsubsection{Position Control}
Focusing firstly on the altitude $z$,
we drive the error exponentially to zero by controlling the acceleration
vector of the quadrotors $\ddot{z}_r$ as in \cite{simplified_model} to satisfy:
\[
 K_{p_z} ( z_r - z_d )  + K_{d_z} (\dot{z}_r - \dot{z}_d ) + \ddot{z}_r - \ddot{z}_d = 0
\]

\noindent\\
Therefore, the virtual input of our control system is:
\begin{equation}
 \ddot{z}_r  =  K_{p_z} e_z + K_{d_z} \dot{e}_z + \ddot{z}_d
    \label{eq:virtual_input}
\end{equation}
where \( K_{p_z} \) and \( K_{d_z} \) are the  proportional and derivative gains, respectively.

\noindent\\
From the simplified dynamics \eqref{eq:position_control_z}, 
the control thrust \( T \) required to maintain the altitude is given by:
\begin{equation}
 T = \frac{m}{\cos\theta \cos\phi} \, (g + \ddot{z}_r)
    \label{eq:true_input}
\end{equation}

\noindent\\
Substituting \( \ddot{z}_r \) from Eq.\ref{eq:virtual_input} in Eq.\ref{eq:true_input},
we obtain:
\begin{equation}
 T = \frac{m}{\cos\theta \cos\phi} \, \left( g + K_{p_z} e_z + K_{d_z} \dot{e}_z + \ddot{z}_d \right)
    \label{eq:desired_thrust}
\end{equation}
%Since we do not need any vertical acceleration we specify $\ddot{z}_d = 0$, questo dillo nell implementazione.
%nell implementazione dire che la traiettoria scelat è una TRAIETTORIA ESPONENZIALE 

\begin{figure}
    \resizebox{\textwidth}{!}{
    \centering
    \begin{tikzpicture}[font=\sffamily, thick, node distance=2cm]
        % Nodes
        \node[draw, fill=orange!50, text centered, minimum width=3cm, minimum height=1.5cm] (attitude) {Attitude Control};
        \node[draw, fill=ocra!50, text centered, minimum width=3cm, minimum height=1.5cm, 
 below right=1cm and -0.25cm of attitude] (position) {Position Control};
        \node[draw=black, line width=2pt, inner sep=0pt, anchor=center, minimum width=3cm, minimum height=2.5cm] 
 at ($(attitude) + (8cm, -0.25cm)$) (drone) {
        \includegraphics[height=2.5cm, width=3cm]{images/quad_model.png}};
        % Arrows
        % Attitude to Drone
        \draw[-stealth] (attitude.east) -- ([yshift=0.25cm] drone.west) 
 node[midway, above] {$\tau_\varphi, \tau_\vartheta, \tau_\psi$};
        % Position to Attitude
        \draw[-stealth] (position.west) -| (attitude.south) 
 node[near end, left] {$\varphi_d, \vartheta_d, \psi_d$};
        % Feedback loop from Drone to Attitude
        \draw[-stealth] ([xshift=1cm] drone.east) 
 -- ++(0,1.5cm) % Move up by 1 unit (cm by default in TikZ)
 -- ([yshift=0.5cm] attitude.north) % Move left towards attitude.north with a shift
 -- (attitude.north); % Move down to the exact attitude.north position
        % Incorrect arrow corrected: Drone east side to itself
        \draw (drone.east) -- ++(1cm, 0)
 node[right] {$\mathbf{e}$};
        % Feedback loop from Drone to Position
        \draw[-stealth] ([xshift=1cm] drone.east) |- ([yshift=0.25cm]position.east);
        % Position to Drone (Thrust, shifted down)
        \draw[-stealth] (position.north) |- ([yshift=-0.25cm] drone.west) 
 node[midway, below right] {$T$};
        % Position Control Outputs to its East Side
        \draw[-stealth] ([xshift=3cm, yshift=-0.25cm] position.east) -- ([yshift=-0.25cm] position.east)
 node[midway, below] {$\mathbf{x}_d, \mathbf{v}_d, \mathbf{a}_d$};    
    \end{tikzpicture}}
    \caption{Block diagram of the PID control for trajectory tracking}
    \label{fig:control_traj_tracking}
\end{figure}

\noindent\\
The control strategy we have adopted is hierarchical \cite{model_quadrotor}
since we have given priority to the 
altitude and horizontal positions control to determine the desired input thrust;
only after we determine this quantity
we define in cascade the control torques $\tau\theta, \tau\phi, \tau\psi$.

\noindent\\
As before we want the position error to exponentially converge to zero,
therefore we desire:
\begin{equation}
    \begin{cases}
 K_{p_x} ( x_r - x_d )  + K_{d_x} (\dot{x}_r -\dot{x}_d) + \ddot{x}_r -\ddot{x}_d  = 0 \\[6pt]
 K_{p_y} (y_r - y_d )  + K_{d_y} ( \dot{y}_r - \dot{y}_d) +  \ddot{y}_r - \ddot{y}_d = 0
    \end{cases}
\end{equation}
where $K_{p_x}$ and $K_{p_y}$ are proportional gains, and $K_{d_x}$ and $K_{d_y}$ are derivative gains.

\noindent \\
From the simplified translational dynamics, Equations~\ref{eq:position_control_x}
and \ref{eq:position_control_y}, we find the desired pitch \( \theta_d \) 
and roll \( \phi_d \) angles that ensure the system converges to the desired trajectory.
We substitute the desired angles and obtain:
\begin{subequations}
    \begin{align}
 \frac{m}{T} \ddot{x}_r &= \cos\psi \sin\theta \cos\phi + \sin\psi \sin\phi \label{eq:T_x} \\[6pt]
 \frac{m}{T} \ddot{y}_r &= \sin\psi \sin\theta \cos\phi - \cos\psi \sin\phi \label{eq:T_y}
    \end{align}
\end{subequations}

\subsubsection{Attitude Control}
After performing algebraic and trigonometric manipulations, we derive expressions for the desired roll and pitch angles:
\begin{equation}
    \phi_d =  \arcsin\left(  (T_y \cos\psi - T_x \sin\psi) \right)
    \label{eq:desire_phi}
\end{equation}
\begin{equation}
    \theta_d = - \arcsin\left(\frac{T_x \cos\psi + T_y \sin\psi}{ \cos\phi_d } \right)
    \label{eq:desire_theta}
\end{equation}
where $T_x = \frac{m}{T} \ddot{x}_r$ and $T_y = \frac{m}{T} \ddot{y}_r$ are the
desired components of the thrust vector in $x$ and $y$ and are found
using Equations \ref{eq:T_x} and \ref{eq:T_y} respectively.

\noindent\\
For the desired yaw angle, we use the relationship between the velocity 
components, so that the quadrotor maintains the correct heading direction.
Specifically, the yaw angle is determined as:
\begin{equation}
    \psi_d = \arctan2(\dot{y}_d, \dot{x}_d),
\end{equation}

\noindent\\
Using the desired angles $\phi_d$, $\theta_d, \psi_d$, the control torques are defined as:
\begin{equation}
    \label{eq:input_phi}
    \tau_\phi = I_x \left(  K_{p_\phi} e_\phi + K_{d_\phi} \dot{e}_\phi \right)
\end{equation}
\begin{equation}
    \label{eq:input_theta}
    \tau_\theta = I_y \left(K_{p_\theta} e_\theta + K_{d_\theta} \dot{e}_\theta \right)
\end{equation}
\begin{equation}
    \label{eq:input_psi}
    \tau_\psi = I_z \left(K_{p_\psi} e_\psi + K_{d_\psi} \dot{e}_\psi \right)
\end{equation}
Where $K_{p_\phi}$, $K_{d_\phi}$, $K_{p_\theta}$, $K_{d_\theta}$, $K_{p_\psi}$, and $K_{d_\psi}$ 
represent the proportional and derivative gains for roll, pitch, and yaw, respectively. 
While the input force was defined earlier in Eq.\ref{eq:true_input}.

\subsubsection{Rotor Velocities}
\tikzset
{%
 pics/cylinder/.style n args={3}{% #1 = radius, #2 = height, #3 = angle
 code={%
      \draw[pic actions] (135:#1) arc (135:315:#1) --++ (0,0,#2) arc (315:135:#1) -- cycle;
      \draw[pic actions] (0,0,#2) circle (#1);
      \foreach\z in {0,1}
 {
        \begin{scope}[canvas is xy plane at z=\z*\h]
          \coordinate (-cen\z) at       (0,0);
          \coordinate (-ESE\z) at    (-#3:#1);
          \coordinate (-ENE\z) at     (#3:#1);
          \coordinate (-NNE\z) at  (90-#3:#1);
          \coordinate (-NNW\z) at  (90+#3:#1);
          \coordinate (-WNW\z) at (180-#3:#1);
          \coordinate (-WSW\z) at (180+#3:#1);
          \coordinate (-SSW\z) at (270-#3:#1);
          \coordinate (-SSE\z) at (270+#3:#1);
        \end{scope}
 }
 }},
}
\begin{figure}
    \centering
    \begin{tikzpicture}[isometric view,line cap=round,line join=round]
    % dimensions
    \def\l{3.7}    % boom length
    \def\R{0.7}    % body radius
    \def\r{0.15} % motor radius
    \def\h{0.2}  % boom and body height
    \pgfmathsetmacro\A{asin(\r*sin(45)/\R)}
    % paths to situate the coordinates
    \foreach[count=\i]\j in {E,N,W,S}
      \pic[draw=none] (\j) at (90*\i-90:\l) {cylinder={\r}{\h}{45}};
    \pic[draw=none] (O) {cylinder={\R}{\h}{\A}};
    % rotations
    \foreach \i/\j in {1/1, 2/-1, 3/1, 4/-1}
 {
      \draw[dashed] (90*\i:\l) + (0,0,-\h) --++ (0,0,-7*\h);
      \begin{scope}[shift={(180-90*\i:\l)},canvas is xy plane at z=-4*\h,x=\j cm]
        \draw[-latex] (.4,0) arc (0:270:0.4) node [right, xshift=1mm] {$\omega_\i$};
      \end{scope}
 }
    % motors
    \foreach\i in {E,N,W,S}
      \pic[fill=gray!90,shift={(0,0,-\h)}] at (\i-cen0) {cylinder={\r}{2*\h}{45}};
    % boom, east
    \draw[fill=gray] (E-SSW1) arc (225:135:\r) -- (O-ENE1) arc (\A:-\A:\R) -- cycle;
    \draw[fill=gray] (E-SSW1) -- (E-SSW0) -- (O-ESE0) -- (O-ESE1) -- cycle;
    % boom, north
    \draw[fill=gray] (N-SSE1) arc (315:225:\r) -- (O-NNW1) arc (90+\A:90-\A:\R) -- cycle;
    \draw[fill=gray] (N-SSW1) -- (N-SSW0) -- (O-NNW0) -- (O-NNW1) -- cycle;
    % frame
    \pic[fill=gray] {cylinder={\R}{\h}{\A}};
    % boom, west
    \draw[fill=gray] (W-NNE1) arc (45:-45:\r) -- (O-WSW1) arc (180+\A:180-\A:\R) -- cycle;
    \draw[fill=gray] (W-SSE1) -- (W-SSE0) -- (O-WSW0) -- (O-WSW1) -- cycle;
    % boom, south
    \draw[fill=gray] (S-NNW1) arc (135:45:\r) -- (O-SSE1) arc (270+\A:270-\A:\R) -- cycle;
    \draw[fill=gray] (S-NNW1) -- (S-NNW0) -- (O-SSW0) -- (O-SSW1) -- cycle;
    % Propellers with alternating red and yellow colors
    \foreach[count=\i]\j in {140,10,60,15}
 {
      \begin{scope}[shift={(90*\i-90:\l)},rotate around z=\j,canvas is xy plane at z=\h,scale=1.5]
        % Alternate colors: red for odd i, yellow for even i
        \ifodd\i
          \def\propColor{ocra} % Odd -> Red
        \else
          \def\propColor{orange} % Even -> Yellow
        \fi
        \draw[fill=\propColor] 
 (0,0) sin  (0.5,0.1) cos  (1,0) sin  (0.5,-0.1) cos (0,0)
 sin (-0.5,0.1) cos (-1,0) sin (-0.5,-0.1) cos (0,0);
        \fill (0,0) circle (0.05);
      \end{scope}
 }
    \foreach\i in {1,2,3,4}
    \draw[thick, -latex] (-90*\i+180:\l) + (0,0,2*\h) --++ (0,0,6*\h) node [right] {$T_\i$};
    % axes
    \draw[ultra thick, green, -latex] (0,0,\h) --++ (0,0,2)  node [above] {$z_r$};
    \draw[ultra thick,blue,-latex] (0,0,\h) --++ (1.5,0,0) node [yshift=3mm] {\strut$y_r$};
    \draw[ultra thick,red,-latex] (0,0,\h) --++ (0,1.5,0) node [yshift=3mm] {\strut$x_r$};
    \draw[dashed] (O-cen1) --++ (-8,-4,0) coordinate (O');
    % ENU Coordinate System
    \draw[ultra thick,blue,-latex] (O') --++ (1,0,0) node [right] {$E$};   % East (E)
    \draw[ultra thick,red,-latex] (O') --++ (0,1,0) node [above] {$N$};   % North (N)
    \draw[ultra thick,green,-latex] (O') --++ (0,0,1) node [above left] {$U$}; % Up (U)
    \fill (O') circle (2pt) node [below] {$O$};
    \end{tikzpicture}
    \caption{Quadrotor model }
\end{figure}
The configuration chosen for the quadrotor to determine the 
relationship between the rotor speeds and the torques 
and thrust vector is the standard "+" configuration, 
as in \cite{figura_bella_drone, model_quadrotor, 
quadrotor_modeling_control_book, backstepping_control, geometric_control}. 
In particular, we define and align the first rotor with the \( x_r \) 
axis of the body/receiver frame, while the rotor aligned with the \( y_r \) 
axis is defined as the second rotor, and we continue counting clockwise,
as seen in Figure \ref{fig:rotor_velocities}.

\noindent\\
Each rotor generates a thrust \( T_i \), where \( i = 1, \dots, 4 \), 
which depends proportionally on the square of the rotor's angular velocity \( \omega_i^2 \). 
Then, the total thrust is simply the sum of the thrusts generated by each individual rotor. 
On the other hand, the four spinning rotors create a yaw rotation (drag effect), 
which depends on whether their rotation is clockwise or counterclockwise. 
This is because the torque generated by each rotor acts in the opposite 
direction to the propeller's motion (angular speed).
While the pitch and roll rotations depend on the arm length $l$ and the
two forces generated by the rotors on the two arms perpendicular to the respective 
rotation axis direction.

\noindent\\
Each rotor’s torque and thrust force depend on the drag 
coefficient \( c_d \in \mathbb{R}_\geq \) and the thrust coefficient 
\( c_t \in \mathbb{R}_\geq \) \cite{geometric_control}, which are parameters influenced by the 
geometry and size of the rotors and they can be determined experimentally 
during static tests.
\[
\begin{bmatrix}
T \\
\tau_\phi \\
\tau_\theta \\
\tau_\psi
\end{bmatrix}
=
\begin{bmatrix}
 c_t & c_t & c_t & c_t \\
    0 & -c_t \cdot l & 0 & c_t \cdot l \\
 c_t \cdot l & 0 & -c_t \cdot l & 0 \\
 -c_d & c_d & -c_d & c_d
\end{bmatrix}
\begin{bmatrix}
\omega_1^2 \\
\omega_2^2 \\
\omega_3^2 \\
\omega_4^2
\end{bmatrix}
= 
\mathbf{A}
\begin{bmatrix}
    \omega_1^2 \\
    \omega_2^2 \\
    \omega_3^2 \\
    \omega_4^2
\end{bmatrix}
\]

\noindent\\
As already stated, the quadrotor is an underactuated system, 
meaning that the 4 controllable inputs (the \( \omega_i \) angular velocities) are 
fewer than the 6 DOF\footnote{DOF stands for Degrees of Freedom} the quadrotor's movement has. 
To determine the rotor velocities \( \omega_i^2 \), 
the matrix \( \mathbf{A} \) must be invertible.
Matrix \( \mathbf{A} \) is invertible when \( c_t, c_d, l \neq 0 \), which is always true. 
Therefore, the matrix is always invertible as:
\begin{equation}
\begin{bmatrix}
\omega_1^2 \\
\omega_2^2 \\
\omega_3^2 \\
\omega_4^2
\end{bmatrix}
=
\mathbf{A}^{-1}
\begin{bmatrix}
T \\
\tau_\phi \\
\tau_\theta \\
\tau_\psi
\end{bmatrix}
\label{eq:rotor_velocities}
\end{equation}
Then, the rotor velocities \( \omega_i \) can then be obtained by 
taking the square root of the computed \( \omega_i^2 \) values.

\subsection{PID Control applied to PSO}
\label{sec:PSO+PID}
\begin{figure}
    \resizebox{\textwidth}{!}{
    \centering
    \begin{tikzpicture}[font=\sffamily, thick, node distance=2cm]
        % Nodes
        \node[draw, fill=orange!50, text centered, minimum width=3cm, minimum height=1.5cm] (attitude) {Attitude Control};
        \node[draw, fill=ocra!50, text centered, minimum width=3cm, minimum height=1.5cm, 
 below right=1.5cm and -0.25cm of attitude] (position) {Position Control};
        \node[draw=black, line width=2pt, inner sep=0pt, anchor=center, minimum width=3cm, minimum height=2.5cm] 
 at ($(attitude) + (8cm, -0.25cm)$) (drone) {
        \includegraphics[height=2.5cm, width=3cm]{images/quad_model.png}};
        \node[draw, fill=green!50, text centered, minimum width=3cm, minimum height=1.4cm]
 at ($(drone) + (0.5cm, -3.3cm)$) (pso) {PSO};
        % Arrows
        % Attitude to Drone
        \draw[-stealth] (attitude.east) -- ([yshift=0.25cm] drone.west) 
 node[midway, above] {$\tau_\varphi(\tau_k), \tau_\vartheta(\tau_k), \tau_\psi(\tau_k)$};
        % Position to Attitude
        \draw[-stealth] (position.west) -| (attitude.south) 
 node[near end, left] {$\varphi_d(\tau_k), \vartheta_d(\tau_k), \psi_d(\tau_k)$};
        % Feedback loop from Drone to Attitude
        \draw[-stealth] ([xshift=1cm] drone.east) 
 -- ++(0,1.5cm) % Move up by 1 unit (cm by default in TikZ)
 -- ([yshift=0.5cm] attitude.north) % Move left towards attitude.north with a shift
 -- (attitude.north); % Move down to the exact attitude.north position
        % Incorrect arrow corrected: Drone east side to itself
        \draw (drone.east) -- ++(1cm, 0)
 node[right] {$\mathbf{e}(\tau_k)$};
        % Feedback loop from Drone to Position
        \draw[-stealth] ([xshift=1cm] drone.east) |- ([yshift=0.5cm]position.east);
        % Position to Drone (Thrust, shifted down)
        \draw[-stealth] (position.north) |- ([yshift=-0.25cm] drone.west) 
 node[midway, below right] {$T(\tau_k)$};
        % Position Control Outputs to its East Side
        \draw[-stealth] (pso.west) -- ([yshift=-0.5cm] position.east)
 node[midway, below] {$\mathbf{x}_d(\tau_s), \mathbf{v}_d(\tau_s)$};    
    \end{tikzpicture}}
    \caption{Block diagram of the PID control applied to the PSO algorithm}
    \label{fig:control_PSO}
\end{figure}
Finally, in order to ensure that the UAVs in the PSO swarm follows
the desired velocity and position commands we integrate the 
PID control described in the previous Section \ref{sec:PID_control} 
with the PSO algorithm described in Section \ref{sec:PSO}.
The block diagram of the complete localization and control 
system is shown in Figure \ref{fig:control_PSO}.

\noindent\\
\textbf{Remark}\noindent\\
Note that the PSO algorithm updates are performed at a sample time 
$\tau_s \neq \tau_k$, where $s \in \mathbb{N}$, which is less 
frequent than the control time step $\tau_k$.
In particular, the PSO algorithm updates once every second, while 
$\tau_k \in \mathbb{R}$.
This implies that at each sample time $\tau_s$ the NSS value is 
evaluated by each $j$-th receiver UAV at $\mathbf{p}_{r_j}(\tau_s)$ using 
Eq.\ref{eq:received_signal}.
This value is used to update the personal best position $\mathbf{pbest}_{j}$
of each UAV and the group best position $\mathbf{gbest}$ of each group,
which occurs when the current NSS value exceeds previous records. 
Then, the UAVs update their 2D velocities and positions
as in Equations~\ref{eq:model_velocity} and \ref{eq:model_position}:
\begin{align}
 \mathbf{v}_{j}(\tau_s+1) &= \omega \mathbf{v}_{j}(\tau_s) 
 + c_1 r_1 \big(\mathbf{pbest}_{j}(\tau_s) - \mathbf{p}_{r_j}(\tau_s)\big) + \notag \\
    &\quad + c_2 r_2 \big(\mathbf{gbest}_l(\tau_s) - \mathbf{p}_{j}(\tau_s)\big) \label{eq:model_velocity2} \\
 \mathbf{p}_{r_j}(\tau_s + 1) &= \mathbf{p}_{r_j}(\tau_s) + \mathbf{v}_{j}(\tau_s+1) \label{eq:model_position2}
\end{align}
where $l = 1, \ldots, M$ is the group best relative to each sub-group.
In addition, the velocity clamping in Eq.\ref{eq:velocity_clamping} is performed right after
this PSO update and the search space boundary conditions as in
Eq.\ref{eq:boundary_condition} are employed to ensure the reference position does not lie outside the boundaries.
We also note that the exclusion zone mechanism remains unvaried
and follows the PSO algorithm in the same way, the check if the drone is in an exlusion zone is done at every PSO $\tau_s$
time step.

\noindent\\
The resulting $\mathbf{v}_{j}(\tau_s+1) = \mathbf{v}_d(\tau_s)$ and $\mathbf{p}_{r_j}(\tau_s + 1) = \mathbf{x}_d(\tau_s)$
are then used as velocity and position desired commands for the PSO, when 
$\tau_s = \tau_k$.
Then, during the next time interval $\Delta \def \tau_{s+1} - \tau_s$ the PID
control algorithm ensures the desired position and velocity are reached,
and the UAV's movement follows the full dynamics system defined in 
Eq.\ref{eq:final_model_more}:
\begin{equation}
 \dot{\mathbf{\xi}}(\tau_k) = f(\mathbf{\xi}(\tau_k))
\end{equation}
where the UAV’s state $\mathbf{\xi}$ is updated at each time step $\tau_k$ in the 
interval $\Delta = \tau_{s+1} - \tau_s$.
This iterative alternation between PSO updates and 
independent UAV 
control enables the swarm to balance global 
exploration and local exploitation.

\noindent\\
Finally, we note that the control inputs (rotor velocities
$\omega_i$) have been limited to $\omega_\text{max}$, 
in order to respect the physical limitations of real 
rotors, in the same way the reference velocities of the 
PSO are limited to a $v_\text{max}$.
For simplicity, we do not limit the linear velocities of the UAVs 
since we have already placed constraints on the angular velocities 
and on the PSO references.

\end{document}
