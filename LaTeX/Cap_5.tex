\chapter{Implementation}
\section{Introduction}
Simulations have been done in MATLAB.
\section{Particle Swarm Optimization}
The PSO\footnote{PSO stands for Particle Swarm Optimization.} algorithm was first introduced in 1995 
\cite{PSO_original}, and it has since proven to be a powerful tool for solving various optimization problems. 
In the standard PSO algorithm, a population of particles is randomly initialized to represent potential candidate 
solutions for the optimization problem. Each particle relies on two important pieces of information: its individual 
best, referred to as \textit{pbest}, and the global best across the entire population, referred to as \textit{gbest}. 
These two values guide the search direction of all particles over the search space. The evaluation of the 
\textit{pbest} for each particle and the \textit{gbest} for the entire population is determined by the function 
that needs to be optimized.

\par In our implementation, each particle corresponds to an individual drone 
within the swarm, and the velocity and position of each drone are updated in 
accordance with the aforementioned standard PSO algorithm. Let $\mathbf{p}_i \in \mathbb{R}^2$ 
for $i = 1, 2, \dots, n$ represent the position vectors of the drones in the 2D plane, 
where $n$ is the total number of drones. The motion of each particle is governed 
by two fundamental equations: the velocity update equation (Eq.~\ref{eq:velocity}) and 
the position update equation (Eq.~\ref{eq:position}).
\begin{align}
    \mathbf{v}_{i}(t+1) &= \omega \, \mathbf{v}_{i}(t) + c_1 r_1 \left( \mathbf{pbest}_{i}(t) - \mathbf{p}_{i}(t) \right) 
    + c_2 r_2 \left( \mathbf{gbest}(t) - \mathbf{p}_{i}(t) \right) \label{eq:velocity} \\
    \mathbf{p}_{i}(t+1) &= \mathbf{p}_{i}(t) + \mathbf{v}_{i}(t+1) \label{eq:position}
\end{align}
    
where $\mathbf{p}_i$, $\mathbf{pbest}_i$, and $\mathbf{gbest}$ represent the position vector of the $i$-th particle, 
the $i$-th particle's individual best position vector, and the global best position vector, 
$\omega$ is the inertia weight, $c_1$ and $c_2$ are positive constants, and
$r_1$ and $r_2$ are random variables uniformly distributed over the interval $[0, 1]$.

\par In the standard PSO algorithm, there is only one global best particle, 
which means that only one optimal solution can be found. This limitation 
poses a challenge when dealing with our problem, where we are looking for multiple sources, 
and therefore, multiple local and global optima exist. To address this challenge, 
we employ the same strategy of a modified version of the PSO algorithm \cite{PSO_IMPORTANT}. 
In this modification, the swarm is divided into $M$ subpopulations, each tasked with exploring 
different regions of the search space. Following this idea, the \textit{gbest} is referred to as 
the best particle of each subpopulation, not as the global best particle in the whole population. 
This means that these $M$ best particles are separately able to catch different optima, at most $M$ optima.

\par The function \texttt{sort\_drones\_in\_groups} returns the number of groups and sorts the 
particles in different groups based on the following logic (see Algorithm~\ref{alg:sort_drones_in_groups}):
\begin{algorithm}[H]
    \caption{\texttt{sort\_drones\_in\_groups} (MATLAB function)}\label{alg:sort_drones_in_groups}
    \begin{algorithmic}[1]
    \State \textbf{Inputs:}
    \State $n\_drones$: Number of drones available for assignment
    \State $n\_sources$: Number of sources to which drones need to be assigned
    \State \textbf{Outputs:}
    \State $group\_indices$: A vector of size $n\_drones$ indicating the assigned group
    \State $n\_groups$: The obtained number of groups
    \If{$n\_particles > n\_sources$}
        \State Assign at least one particle to each group, following mathematical order
        \State Randomly assign remaining particles to existing groups
    \ElsIf{$n\_particles = n\_sources$}
        \State Assign each particle to a unique group
    \Else
        \State Orderly assign particles up to $n\_drones$
    \EndIf
    \State Set the number of groups: $n\_groups = max(group\_indices)$
    \end{algorithmic}
\end{algorithm}

\par Note that the function \texttt{sort\_drones\_in\_groups} ensures the creation of sufficient groups 
for the localization of multiple sources only when the number of drones is equal to or greater than 
the number of sources.

\section{Exploration phase}
\par Unlike the modified PSO algorithm, in our implementation, the drones are not randomly initialized. 
At the start of the simulation, all drones are located at the origin of the search space. 
An Exploration Phase begins where the PSO algorithm is not yet employed. 
During this phase, the drones move according to predefined trajectories at maximum speed $v_{\text{max}}$. 
The trajectories are determined based on the number of drones and follow a radial pattern, as shown in Figure \ref{fig:exploration_pattern}. 
The drones follow these trajectories until they have covered a distance $travel\_distance$ equivalent to half the boundary of the search space.
The goal each drone needs to reach is computed using the following Algorithm~\ref{alg:exploration_goals}:

\begin{algorithm}[H]
    \caption{\texttt{exploration\_goals} (MATLAB function)} \label{alg:exploration_goals}
    \begin{algorithmic}[1]
        \State \textbf{Input:} $n\_{drones}$, $x\_{max}$
        \State \textbf{Output:} $goals$ 
        \State Initialize an empty array $goals$
        \State Set $angle\_step = 360 / n\_{drones}$
        \State Set $travel\_distance = x\_{max} / 2$ 
        \For{each drone $i = 1, 2, \dots, n\_{drones}$}
            \State Get angle for the current drone: $drone\_angle = i \cdot angle\_step$
            \State Calculate slope: $m = \tan(\texttt{deg2rad}(drone\_angle))$
            \If{$drone\_angle > 315$ \textbf{or} $drone\_angle \leq 45$} 
                \State $goal = [travel\_distance, m \cdot travel\_distance]$ \Comment{1st quadrants}
            \ElsIf{$drone\_angle > 45$ \textbf{and} $drone\_angle \leq 135$}
                \State $goal = [travel\_distance / m, travel\_distance]$ \Comment{2nd quadrant}
            \ElsIf{$drone\_angle > 135$ \textbf{and} $drone\_angle \leq 225$}
                \State $goal = [-travel\_distance, m \cdot -travel\_distance]$ \Comment{3rd quadrant}
            \ElsIf{$drone\_angle > 225$ \textbf{and} $drone\_angle \leq 315$}
                \State $goal = [-travel\_distance / m, -travel\_distance]$ \Comment{4th quadrant}
            \EndIf
            \State Store the goal for drone $i$ in $goals[i]$
        \EndFor
        \State Return $goals$
    \end{algorithmic}
\end{algorithm}

where $angle\_step$ is the angular increment to uniformly divide the space, $drone\_angle$ represents the angle assigned to each drone, determining its trajectory, 
while $m$ is the slope of the trajectory calculated from the drone's angle. 

\begin{figure}
    \centering
    \includegraphics[width=\textwidth]{images/exploration_pattern.jpg} 
    \caption{Radial exploration pattern for 5 drones at the end of the Exploration Phase.}
    \label{fig:exploration_pattern}
\end{figure}

\section{Exploitation Phase}
\subsection{Velocity Update}
At each time step, the velocity update of the standard PSO algorithm is modified in order to favor the complete 
exploration of the search space and to avoid premature convergence to local maxima, where a source is not present. 
A uniform random noise is added to the velocity of each particle to achieve a \textit{persistence of excitation},
allowing every drone to explore new and different directions, 
as described in the following formula:
\[
\mathbf{v}_i = \mathbf{v}_i + \beta \cdot \mathbf{r} \cdot ||\mathbf{v}_i||
\] \label{eq:persistence_of_excitation}
where:
\begin{itemize}
    \item \(\beta\) is an hyperparameter chosen in the [0,1] range.
    \item \(\mathbf{r} \sim \mathcal{U}(-1, 1)\) represents a random vector where each component is uniformly distributed between \(-1\) and \(1\).
    \item \(||\mathbf{v}_i||\) is the magnitude of the velocity vector of particle \(i\).
\end{itemize}
Furthermore, not only because of the physical velocity limitations of the drones, but also to ensure smoother updates 
and prevent instability due to excessive velocity, we clamp the velocity of each drone 
to a maximum value \(v_{\text{max}}\):
\[
\mathbf{v}_i = 
\begin{cases} 
v_{\text{max}} \cdot \frac{\mathbf{v}_i}{\|\mathbf{v}_i\|}, & \text{if } \|\mathbf{v}_i\| \geq v_{\text{max}} \\
\mathbf{v}_i, & \text{otherwise}
\end{cases}
\] \label{eq:velocity_clamping}


\subsection{Exclusion Zone Mechanism}
An additional modification to the standard PSO algorithm 
is the introduction of an exclusion zone mechanism.
This mechanism prevents multiple drones from focusing 
on the same source. It involves defining regions that 
other particles should avoid, promoting better exploration 
and reducing redundancy in source detection. The exclusion 
zone mechanism involves several key parts:
\begin{itemize}
    \item \textbf{Detection}: A drone sets its exclusion zone 
    when it identifies a source with a signal strength (NSS) 
    exceeding a predefined threshold.
    \item \textbf{Sharing}: The drone shares the position of 
    its exclusion zone with neighboring drones.
    \item \textbf{Checking}: Each drone continuously checks 
    its position against all shared exclusion zones.
    \item \textbf{Avoidance}: If a drone finds itself within 
    a shared exclusion zone, it moves away from the zone 
    following a calculated escape vector.
\end{itemize}

\subsubsection{Detection}
Each drone establishes an exclusion zone when it detects a 
source, meaning it has computed an NSS higher than a certain 
threshold. The exclusion zone is defined as a circular area 
centered around the position of the drone where the source 
was detected. The radius of this zone is a fixed parameter, 
chosen experimentally, which determines the \textit{resolution} 
of the algorithm.

\subsubsection{Sharing}
Our algorithm favors a decentralized approach, which is useful 
in scenarios where communication between drones is not always 
possible or easy. A drone can communicate with another when 
they are less than 5 meters apart (\(r_{\text{comm}}\)).
When a drone identifies a source 
and sets its exclusion zone, it shares the estimated position 
of the source with the drones within the communication range. 
Each drone maintains a list of exclusion zones that it has 
received from others. This sharing process helps the swarm 
avoid redundant exploration around already identified sources.

\subsubsection{Avoidance}
When a drone detects that it is within the radius of a shared 
exclusion zone, it is programmed to move away from it. 
The drone computes a new goal position where it needs to go, far from the 
exclusion zone . After it reaches the goal, 
the PSO algorithm resumes, searching for a new source 
in a different area of the space.

The goal position is calculated using the vector joining 
the exclusion zone center \(\mathbf{c}\) and the current 
position of the drone \(\mathbf{p}_{\text{in\_zone}}\), when the drone finds itself 
in an exclusion zone. The formula is given by:

\[
\mathbf{d} = \mathbf{c} - \mathbf{p}_{\text{in\_zone}}
\]
\[
\mathbf{p}_{\text{goal}} = \mathbf{p}_{\text{in\_zone}} + \alpha \frac{\mathbf{d}}{\|\mathbf{d}\|}
\] \label{eq:move_away}

where:
\begin{itemize}
    \item \(\mathbf{d}\): Direction vector from the exclusion 
    zone center to the drone's position.
    \item \(\alpha\): Step size parameter, determining the 
    distance the drone should travel away from the exclusion zone.
    \item \(\mathbf{p}_{\text{goal}}\): Updated goal position of the drone.
    \item \(\|\mathbf{d}\|\): Norm (magnitude) of the direction 
    vector \(\mathbf{d}\), used to normalize the direction.
\end{itemize}
This calculation ensures that the drone moves directly away 
from the exclusion zone and covers a distance proportional 
to \(\alpha\). 
\\

The exclusion zone mechanism allows the swarm 
to adaptively adjust its search strategy based on the locations 
of previously detected sources, leading to faster convergence 
and improved accuracy in multi-source localization.
Finally, we can present the complete modified PSO algorithm in 
Algorithm \ref{alg:PSO}: 
\begin{algorithm}
    \caption{Particle Swarm Optimization for Multi-Source Localization}\label{alg:PSO}
    \begin{algorithmic}[1]
        \State \textbf{Initialize} drones' positions to the center of the search space.
        \State \textbf{Initialize} group best positions \( G_{\text{best}} \) and values \(\textit{NSS}_{\text{best}}\).
        \State \textbf{Assign} each drone to a group using function \ref{alg:sort_drones_in_groups}.
        
        \State \textbf{Exploration Phase}:
        \State \textbf{Compute} exploration goals using function \ref{alg:exploration_goals}.
        \For{each drone \( i \)}
            \State \textbf{Do}: reach goal.
        \EndFor

        \State \textbf{Exploitation Phase}:
        \For{each iteration \( t = 1 \) to \( n_{iters} \)}
            \For{each drone \( i \)}
                \State \textbf{Update} velocity using standard PSO formula as in Eq.\eqref{eq:velocity}.
                \State \textbf{Apply} persistence of excitation as in Eq. \eqref{eq:persistence_of_excitation}.
                \State \textbf{Limit} velocity to \( v_{\text{max}} \) as in Eq. \eqref{eq:velocity_clamping}.
                \State \textbf{Update} position as in Eq. \eqref{eq:position}.
                \State \textbf{Apply} boundary conditions to keep \(\mathbf{p}_i(t+1)\) within search bounds.
                
                \For{each other drone \( j \neq i \)}
                    \If{\(\|\mathbf{p}_i(t+1) - \mathbf{p}_j(t+1)\| \leq r_{\text{comm}}\)}
                        \If{\(\text{NSS}_{i}\) or \(\text{NSS}_{j} > \text{threshold}\)}
                            \State \textbf{Share} exclusion zones between drones \( i \) and \( j \).
                        \EndIf
                    \EndIf
                \EndFor
                
                \State \textbf{Check} if drone \( i \) is within an exclusion zone.
                \If{drone \( i \) is in an exclusion zone}
                    \If{drone \( i \) is not alone in its group}
                        \State \textbf{Reassign} drone \( i \) to a new group.
                        \State \textbf{Initialize} \( G_{\text{best}} \) and \(\textit{NSS}_{\text{best}}\) of the new group.
                    \EndIf
                    \State \textbf{Move} away from exclusion zone as in Eq. \eqref{eq:move_away}.
                    \State \textbf{Reset} personal best \(\mathbf{p}_{\text{best}, i}\).
                    \State \textbf{Set} drone \( i \) inertia \(\omega = 0\).
                \Else
                    \State \textbf{Evaluate} NSS at \(\mathbf{p}_i(t+1)\).
                    \If{current NSS \( > \) personal best NSS}
                        \State \textbf{Update} personal best \(\mathbf{p}_{\text{best}, i}\).
                    \EndIf
                    \If{current NSS \( > \) group best NSS}
                        \State \textbf{Update} group best \( G_{\text{best}} \).
                    \EndIf
                \EndIf
            \EndFor
        \EndFor
        
        \State \textbf{Return} \( G_{\text{best}} \).
    \end{algorithmic}
\end{algorithm}
Note that the inertia of a drone that has found a source is set to zero (\(\omega = 0\)), increasing
convergence speed.
Throughout the process, each drone updates its personal 
and group best positions based on newly evaluated NSS 
values, like in the standard PSO algorithm. The final output is the set of best estimates 
\( G_{\text{best}} \), composed of the best estimated position of a source by each group.